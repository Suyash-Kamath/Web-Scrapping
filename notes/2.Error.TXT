The Problem 
SSLError: [SSL: WRONG_VERSION_NUMBER]

Means :
I (your code) tried to connect securely to the website using HTTPS, but the connection failed because I don‚Äôt understand the version of security protocol the site is using.

 Wait‚Ä¶ What is SSL?
SSL (now called TLS) is like a security layer used when websites use HTTPS (instead of HTTP).
It:

Encrypts the data

Ensures your connection is safe and private

When you open a website like https://www.yelu.in, the browser or your Python code:

Says: ‚ÄúHey, are you secure?‚Äù

The server replies: ‚ÄúYes, let‚Äôs talk securely using TLS v1.3‚Äù

Python says: ‚ÄúWait! I only know v1.0 üòµ‚Äçüí´‚Äù

BOOM üí• ‚Äî Error!


| Term                 | Meaning                                                                  |
| -------------------- | ------------------------------------------------------------------------ |
| **SSL/TLS**          | Security protocol (used in `https://` websites) ‚Äî like HTTPS‚Äôs bodyguard |
| **requests**         | Python library to visit websites                                         |
| **`requests.get()`** | Your code saying ‚ÄúHi, give me the webpage‚Äù                               |
| **SSL Error**        | The handshake between your code and the site failed                      |
| **Session**          | Like a browser tab ‚Äî keeps cookies, headers, etc.                        |
| **Adapter**          | Special settings attached to sessions (like retrying or SSL rules)       |
| **User-Agent**       | Tells the website who‚Äôs making the request (browser, bot, etc.)          |
| **verify=False**     | Skips the security check (insecure ‚Äì only for testing)                   |


 Why You Got This as a Beginner
You're doing this on:

Windows

Python 3.13 (very new, might be buggy)

Maybe behind a corporate network / antivirus / VPN
And trying to connect to a secure site (https://www.yelu.in) using the requests library.

So Python tries to connect securely ‚Äî but fails to match the expected SSL protocol ‚Äî hence the error.

What Can You Do (No Coding Knowledge Needed)
‚úÖ OPTION 1 ‚Äî Quickest & Simplest Fix (Just for Testing)
Change:
res = requests.get(url, headers=headers)
To:
res = requests.get(url, headers=headers, verify=False)
This turns off the security check (like skipping OTP during login).
‚ö†Ô∏è Use only for testing ‚Äî don‚Äôt use this for banking apps or real users.

 What Is a Security Protocol?
A security protocol is like a set of rules that computers use when they talk to each other securely.

Imagine you're sending a secret letter to a friend. You both agree:

To use a lockbox

The box has a specific type of lock (say, ‚Äúv1‚Äù)

You both must have keys that match that lock

If your friend upgrades to a new lock ("v3") but you still have the old key ("v1"), you can't open it. üß±

This is exactly what happens in computers when talking to a secure website.

Great question, and I‚Äôm really glad you're digging deeper. Let's break it down **very simply**.

---

# üõ°Ô∏è What Is a **Security Protocol**?

A **security protocol** is like a set of rules that computers use when they talk to each other **securely**.

Imagine you're sending a secret letter to a friend. You both agree:

* To use a **lockbox**
* The box has a specific type of lock (say, ‚Äúv1‚Äù)
* You both must have **keys** that match that lock

If your friend upgrades to a new lock ("v3") but you still have the old key ("v1"), you can't open it. üß±

This is **exactly what happens** in computers when talking to a secure website.

---

## ‚úÖ Example in the Real World

When you open a secure website like:

```
https://www.google.com
https://www.yelu.in
```

Your browser (or Python code) says:

> ‚ÄúHey server, let‚Äôs talk privately and securely ‚Äî what rules (protocol) do you use?‚Äù

The server replies:

> ‚ÄúI use TLS 1.3 (latest secure version)!‚Äù

If your Python setup only supports old versions (like TLS 1.0), then:

> ‚ùå You can‚Äôt talk securely ‚Äî connection fails ‚Äî hence the error: `WRONG_VERSION_NUMBER`

---

## üîê Main Security Protocols for HTTPS

| Protocol      | Full Name                | Status        | Notes                |
| ------------- | ------------------------ | ------------- | -------------------- |
| SSL 2.0 / 3.0 | Secure Sockets Layer     | ‚ùå Obsolete    | Very old             |
| TLS 1.0       | Transport Layer Security | ‚ö†Ô∏è Deprecated | Not secure anymore   |
| TLS 1.2       | Transport Layer Security | ‚úÖ Common      | Still widely used    |
| TLS 1.3       | Transport Layer Security | ‚úÖ Modern      | Most secure and fast |

---

## üéØ So Yes ‚Äî **Version Does Matter!**

If your system:

* Tries to connect using **an old or wrong version**
* While the server expects **a new version**

Then the connection fails. That‚Äôs what your error was:

```
SSLError: [SSL: WRONG_VERSION_NUMBER]
```

---

## üß† In Simple Words:

| You Say                             | Computer Terms          |
| ----------------------------------- | ----------------------- |
| ‚ÄúLet's talk secretly‚Äù               | Secure HTTPS connection |
| ‚ÄúWhat lock do you use?‚Äù             | TLS version handshake   |
| ‚ÄúOh, I don‚Äôt support that version!‚Äù | `SSLError` happens      |

---

## üîß Why It Matters in Python/Code

You need:

* Python and libraries that **understand modern TLS versions**
* Some old Python builds or wrong SSL settings might only support **TLS 1.0**, which is rejected by modern websites

That‚Äôs why:

* Python 3.11 (with updated SSL) works
* Python 3.13 might be buggy
* `requests.get(..., verify=False)` skips the version check ‚Äî but it‚Äôs insecure

---

## ‚úÖ Summary

| Question                     | Answer                                                              |
| ---------------------------- | ------------------------------------------------------------------- |
| What is a security protocol? | A rule set for safe communication between computers (like TLS)      |
| Does version matter?         | Yes! Old versions = blocked. Only TLS 1.2+ is accepted now          |
| Why did I get an error?      | Your Python tried to connect using a wrong/old/incompatible version |

---

Great question again! Let‚Äôs explain **`verify=False`** in a **super simple, beginner-friendly way**.

---

## üõ°Ô∏è What is `verify=False` in Python?

When you make a request to a website using `requests.get()` like this:

```python
import requests

url = "https://example.com"
response = requests.get(url)
```

Python (through the `requests` library) tries to:

> ‚úÖ **Verify that the website is safe and real**
> by checking its **SSL certificate**.

---

### üß† What is an SSL Certificate?

It's like an **identity card** for the website.

* It tells your computer: ‚ÄúYes, I really am Google (or Yelu or Amazon), not a fake site.‚Äù
* It's part of how `https://` keeps you safe.

---

## ‚ùå What If Something‚Äôs Wrong?

If the SSL certificate is:

* Expired
* Fake
* Mismatched
* Or your system can‚Äôt validate it properly‚Ä¶

You‚Äôll get an error like this:

```
requests.exceptions.SSLError: certificate verify failed
```

---

## ‚úÖ What Does `verify=False` Do?

It tells Python:

> "Hey... **don‚Äôt check** if the SSL certificate is valid. Just connect anyway."

Here‚Äôs the syntax:

```python
response = requests.get("https://example.com", verify=False)
```

It **skips SSL verification**.

---

## ü§î Is It Safe?

Not really.

| ‚úÖ Good for Testing  | ‚ùå Not Good for Production  |
| ------------------- | -------------------------- |
| Learning purposes   | Banking apps               |
| Broken or dev sites | Sending personal data      |
| Internal websites   | Secure user authentication |

If you turn off SSL verification, you're like:

> "I‚Äôll trust whoever this website says they are ‚Äî no ID needed."
> Which is risky if you're sending passwords or private data.

---

## üîí Real World Analogy:

| Without `verify=False`         | With `verify=False`                                       |
| ------------------------------ | --------------------------------------------------------- |
| Bouncer checks ID before entry | You walk into a building without anyone verifying your ID |
| Secure, but slower             | Fast, but unsafe                                          |

---

## üí° Summary:

| Term                      | Meaning                                                       |
| ------------------------- | ------------------------------------------------------------- |
| `verify=True` *(default)* | Check if the website is **secure and real** (recommended)     |
| `verify=False`            | **Skip security check** ‚Äî only use when you're sure it's safe |

---

## üß™ Example for You

```python
import requests

url = "https://self-signed.badssl.com/"  # Fake SSL certificate site
try:
    res = requests.get(url)
    print("‚úÖ Success:", res.status_code)
except Exception as e:
    print("‚ùå Error:", e)

# Now try again with verify=False
res = requests.get(url, verify=False)
print("‚úÖ Success (insecure way):", res.status_code)
```

---
The full form of SSL is Secure Sockets Layer. It is a security protocol that creates an encrypted link between a web server and a browser, ensuring secure communication and protecting sensitive data during online transactions and interactions. 

The full form of SSL is Secure Sockets Layer. It is a security protocol that creates an encrypted link between a web server and a browser, ensuring secure communication and protecting sensitive data during online transactions and interactions. 
Here's a more detailed explanation:
Secure:
SSL provides a secure connection, meaning that data transmitted between the server and browser is encrypted and cannot be easily intercepted by third parties. 
Sockets:
Sockets are a way for computers to communicate with each other over a network. SSL uses sockets to establish a secure connection between a web server and a browser. 
Layer:
SSL is a layer of security that sits between the application layer (like a web browser) and the transport layer (like TCP/IP). 
In essence, SSL is the foundation for secure websites, ensuring that when you see "https://" in the address bar, your connection is encrypted and protected. 

verify=False tells Python:

"Don‚Äôt check the website‚Äôs security certificate. Just connect anyway."

‚úÖ **Exactly!**

`verify=False` tells Python:

> **"Don‚Äôt check the website‚Äôs security certificate. Just connect anyway."**

---

### üîí Normally (default `verify=True`):

Python acts like a security guard:

* ‚ÄúIs this website secure?‚Äù
* ‚ÄúIs it using a valid SSL certificate?‚Äù
* ‚ÄúDoes it match the domain?‚Äù

If not ‚Üí ‚ùå **Throws an error**

---

### üßØ With `verify=False`:

Python says:

> ‚ÄúI won‚Äôt check anything. Just give me the page, even if it might be fake or unsafe.‚Äù

‚úîÔ∏è Good for:

* Testing
* Learning
* Internal tools

‚ùå Bad for:

* Sending passwords
* Dealing with real users
* Financial, health, or personal data

---

### üß† In 1 Line:

> ‚úÖ `verify=True` = Be safe
> ‚ö†Ô∏è `verify=False` = Trust blindly (only when **you** are sure it's safe)

---
