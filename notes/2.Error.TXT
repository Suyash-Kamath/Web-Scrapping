The Problem 
SSLError: [SSL: WRONG_VERSION_NUMBER]

Means :
I (your code) tried to connect securely to the website using HTTPS, but the connection failed because I donâ€™t understand the version of security protocol the site is using.

 Waitâ€¦ What is SSL?
SSL (now called TLS) is like a security layer used when websites use HTTPS (instead of HTTP).
It:

Encrypts the data

Ensures your connection is safe and private

When you open a website like https://www.yelu.in, the browser or your Python code:

Says: â€œHey, are you secure?â€

The server replies: â€œYes, letâ€™s talk securely using TLS v1.3â€

Python says: â€œWait! I only know v1.0 ğŸ˜µâ€ğŸ’«â€

BOOM ğŸ’¥ â€” Error!


| Term                 | Meaning                                                                  |
| -------------------- | ------------------------------------------------------------------------ |
| **SSL/TLS**          | Security protocol (used in `https://` websites) â€” like HTTPSâ€™s bodyguard |
| **requests**         | Python library to visit websites                                         |
| **`requests.get()`** | Your code saying â€œHi, give me the webpageâ€                               |
| **SSL Error**        | The handshake between your code and the site failed                      |
| **Session**          | Like a browser tab â€” keeps cookies, headers, etc.                        |
| **Adapter**          | Special settings attached to sessions (like retrying or SSL rules)       |
| **User-Agent**       | Tells the website whoâ€™s making the request (browser, bot, etc.)          |
| **verify=False**     | Skips the security check (insecure â€“ only for testing)                   |


 Why You Got This as a Beginner
You're doing this on:

Windows

Python 3.13 (very new, might be buggy)

Maybe behind a corporate network / antivirus / VPN
And trying to connect to a secure site (https://www.yelu.in) using the requests library.

So Python tries to connect securely â€” but fails to match the expected SSL protocol â€” hence the error.

What Can You Do (No Coding Knowledge Needed)
âœ… OPTION 1 â€” Quickest & Simplest Fix (Just for Testing)
Change:
res = requests.get(url, headers=headers)
To:
res = requests.get(url, headers=headers, verify=False)
This turns off the security check (like skipping OTP during login).
âš ï¸ Use only for testing â€” donâ€™t use this for banking apps or real users.

 What Is a Security Protocol?
A security protocol is like a set of rules that computers use when they talk to each other securely.

Imagine you're sending a secret letter to a friend. You both agree:

To use a lockbox

The box has a specific type of lock (say, â€œv1â€)

You both must have keys that match that lock

If your friend upgrades to a new lock ("v3") but you still have the old key ("v1"), you can't open it. ğŸ§±

This is exactly what happens in computers when talking to a secure website.

Great question, and Iâ€™m really glad you're digging deeper. Let's break it down **very simply**.

---

# ğŸ›¡ï¸ What Is a **Security Protocol**?

A **security protocol** is like a set of rules that computers use when they talk to each other **securely**.

Imagine you're sending a secret letter to a friend. You both agree:

* To use a **lockbox**
* The box has a specific type of lock (say, â€œv1â€)
* You both must have **keys** that match that lock

If your friend upgrades to a new lock ("v3") but you still have the old key ("v1"), you can't open it. ğŸ§±

This is **exactly what happens** in computers when talking to a secure website.

---

## âœ… Example in the Real World

When you open a secure website like:

```
https://www.google.com
https://www.yelu.in
```

Your browser (or Python code) says:

> â€œHey server, letâ€™s talk privately and securely â€” what rules (protocol) do you use?â€

The server replies:

> â€œI use TLS 1.3 (latest secure version)!â€

If your Python setup only supports old versions (like TLS 1.0), then:

> âŒ You canâ€™t talk securely â€” connection fails â€” hence the error: `WRONG_VERSION_NUMBER`

---

## ğŸ” Main Security Protocols for HTTPS

| Protocol      | Full Name                | Status        | Notes                |
| ------------- | ------------------------ | ------------- | -------------------- |
| SSL 2.0 / 3.0 | Secure Sockets Layer     | âŒ Obsolete    | Very old             |
| TLS 1.0       | Transport Layer Security | âš ï¸ Deprecated | Not secure anymore   |
| TLS 1.2       | Transport Layer Security | âœ… Common      | Still widely used    |
| TLS 1.3       | Transport Layer Security | âœ… Modern      | Most secure and fast |

---

## ğŸ¯ So Yes â€” **Version Does Matter!**

If your system:

* Tries to connect using **an old or wrong version**
* While the server expects **a new version**

Then the connection fails. Thatâ€™s what your error was:

```
SSLError: [SSL: WRONG_VERSION_NUMBER]
```

---

## ğŸ§  In Simple Words:

| You Say                             | Computer Terms          |
| ----------------------------------- | ----------------------- |
| â€œLet's talk secretlyâ€               | Secure HTTPS connection |
| â€œWhat lock do you use?â€             | TLS version handshake   |
| â€œOh, I donâ€™t support that version!â€ | `SSLError` happens      |

---

## ğŸ”§ Why It Matters in Python/Code

You need:

* Python and libraries that **understand modern TLS versions**
* Some old Python builds or wrong SSL settings might only support **TLS 1.0**, which is rejected by modern websites

Thatâ€™s why:

* Python 3.11 (with updated SSL) works
* Python 3.13 might be buggy
* `requests.get(..., verify=False)` skips the version check â€” but itâ€™s insecure

---

## âœ… Summary

| Question                     | Answer                                                              |
| ---------------------------- | ------------------------------------------------------------------- |
| What is a security protocol? | A rule set for safe communication between computers (like TLS)      |
| Does version matter?         | Yes! Old versions = blocked. Only TLS 1.2+ is accepted now          |
| Why did I get an error?      | Your Python tried to connect using a wrong/old/incompatible version |

---

Great question again! Letâ€™s explain **`verify=False`** in a **super simple, beginner-friendly way**.

---

## ğŸ›¡ï¸ What is `verify=False` in Python?

When you make a request to a website using `requests.get()` like this:

```python
import requests

url = "https://example.com"
response = requests.get(url)
```

Python (through the `requests` library) tries to:

> âœ… **Verify that the website is safe and real**
> by checking its **SSL certificate**.

---

### ğŸ§  What is an SSL Certificate?

It's like an **identity card** for the website.

* It tells your computer: â€œYes, I really am Google (or Yelu or Amazon), not a fake site.â€
* It's part of how `https://` keeps you safe.

---

## âŒ What If Somethingâ€™s Wrong?

If the SSL certificate is:

* Expired
* Fake
* Mismatched
* Or your system canâ€™t validate it properlyâ€¦

Youâ€™ll get an error like this:

```
requests.exceptions.SSLError: certificate verify failed
```

---

## âœ… What Does `verify=False` Do?

It tells Python:

> "Hey... **donâ€™t check** if the SSL certificate is valid. Just connect anyway."

Hereâ€™s the syntax:

```python
response = requests.get("https://example.com", verify=False)
```

It **skips SSL verification**.

---

## ğŸ¤” Is It Safe?

Not really.

| âœ… Good for Testing  | âŒ Not Good for Production  |
| ------------------- | -------------------------- |
| Learning purposes   | Banking apps               |
| Broken or dev sites | Sending personal data      |
| Internal websites   | Secure user authentication |

If you turn off SSL verification, you're like:

> "Iâ€™ll trust whoever this website says they are â€” no ID needed."
> Which is risky if you're sending passwords or private data.

---

## ğŸ”’ Real World Analogy:

| Without `verify=False`         | With `verify=False`                                       |
| ------------------------------ | --------------------------------------------------------- |
| Bouncer checks ID before entry | You walk into a building without anyone verifying your ID |
| Secure, but slower             | Fast, but unsafe                                          |

---

## ğŸ’¡ Summary:

| Term                      | Meaning                                                       |
| ------------------------- | ------------------------------------------------------------- |
| `verify=True` *(default)* | Check if the website is **secure and real** (recommended)     |
| `verify=False`            | **Skip security check** â€” only use when you're sure it's safe |

---

## ğŸ§ª Example for You

```python
import requests

url = "https://self-signed.badssl.com/"  # Fake SSL certificate site
try:
    res = requests.get(url)
    print("âœ… Success:", res.status_code)
except Exception as e:
    print("âŒ Error:", e)

# Now try again with verify=False
res = requests.get(url, verify=False)
print("âœ… Success (insecure way):", res.status_code)
```

---
The full form of SSL is Secure Sockets Layer. It is a security protocol that creates an encrypted link between a web server and a browser, ensuring secure communication and protecting sensitive data during online transactions and interactions. 

The full form of SSL is Secure Sockets Layer. It is a security protocol that creates an encrypted link between a web server and a browser, ensuring secure communication and protecting sensitive data during online transactions and interactions. 
Here's a more detailed explanation:
Secure:
SSL provides a secure connection, meaning that data transmitted between the server and browser is encrypted and cannot be easily intercepted by third parties. 
Sockets:
Sockets are a way for computers to communicate with each other over a network. SSL uses sockets to establish a secure connection between a web server and a browser. 
Layer:
SSL is a layer of security that sits between the application layer (like a web browser) and the transport layer (like TCP/IP). 
In essence, SSL is the foundation for secure websites, ensuring that when you see "https://" in the address bar, your connection is encrypted and protected. 

verify=False tells Python:

"Donâ€™t check the websiteâ€™s security certificate. Just connect anyway."

âœ… **Exactly!**

`verify=False` tells Python:

> **"Donâ€™t check the websiteâ€™s security certificate. Just connect anyway."**

---

### ğŸ”’ Normally (default `verify=True`):

Python acts like a security guard:

* â€œIs this website secure?â€
* â€œIs it using a valid SSL certificate?â€
* â€œDoes it match the domain?â€

If not â†’ âŒ **Throws an error**

---

### ğŸ§¯ With `verify=False`:

Python says:

> â€œI wonâ€™t check anything. Just give me the page, even if it might be fake or unsafe.â€

âœ”ï¸ Good for:

* Testing
* Learning
* Internal tools

âŒ Bad for:

* Sending passwords
* Dealing with real users
* Financial, health, or personal data

---

### ğŸ§  In 1 Line:

> âœ… `verify=True` = Be safe
> âš ï¸ `verify=False` = Trust blindly (only when **you** are sure it's safe)

---
